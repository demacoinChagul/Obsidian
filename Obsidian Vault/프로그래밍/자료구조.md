# 자료구조의 구분

1. 깊이 우선 검색
![[jaryogujo one]]
 - **기본 원리**: 시작 정점에서 출발하여 한 경로를 따라 갈 수 있는 데까지 계속 탐색하고, 더 이상 갈 곳이 없으면 가장 마지막에 만났던 갈림길로 되돌아가 다른 경로를 탐색한다.

 1. 1부터 시작한다고 한다면
 2. 1을 지나쳐 2 혹은 3으로 간다. 그리고 1을 스택영역(왼쪽 박스) 아래순서로 안에 넣는다
 3. 반복하다 길이 막히면 스택영역에서 맨 위에서 빼고 찾는다
2. 너비 우선 검색
![[jaryogujo one]]
- **기본 원리**: 시작 정점에서 출발하여 인접한 모든 정점을 먼저 탐색한 후, 그 다음 단계로 넘어가 인접한 정점들의 인접 정점을 탐색한다.

 1. 1부터 시작한다고 한다면 \[1]
 2. 1을 큐에서 꺼내고 인접한 2, 3을 추가한다 \[2, 3]
 3. 2를 큐에서 꺼내고 인접한 4, 5를 추가한다 \[3, 4, 5]
 4. 3을 큐에서 꺼내고 인접한 6, 7을 추가한다 \[4, 5, 6, 7]
 5. 4를 큐에서 꺼내고 인접한 8을 추가한다 \[5, 6, 7, 8]
 6. 5를 큐에서 꺼내고 인접한 8이 이미 큐에 있으므로 추가하지 않는다 \[6, 7, 8]
 7. 6을 큐에서 꺼내고 인접한 8이 이미 큐에 있으므로 추가하지 않는다 \[7, 8]
 8. 7을 큐에서 꺼내고 인접한 8이 이미 큐에 있으므로 추가하지 않는다 \[8]
 9. 8을 큐에서 꺼낸다 \[]

# 메모리의 분류와 특징
<table>
<tr>
<th colspan=3 >
분류
</th>
<th>
특징
</th>
</tr>
<tr>
<td colspan=3>
Stack
</td>
<td>
- 자동 변수이고 지역변수인 변수가 사용하는 메모리 영역<br> - 임시 메모리 성격 <br> - 크기가 작고(최대 1MB) 관리(할당 및 반환)가 자동으로 이루어짐
</td>
</tr>
<tr>
<td colspan=3>
Heap
</td>
<td>
- 동적 할당 가능한 자유 메모리 영역 <br>- 관리는 개발자가 직접(할당 및 해제 코드로 구현)
</td>
</tr>
<tr>
<td rowspan=3>
PE
</td>
<td colspan=2>
Text section
</td>
<td>
- 소스코드가 기계어로 번역되어 저장되는 메모리 영역 <br>- 읽기 전용
</td>
<tr>
<td rowspan=2>
Data section
</td>
<td>
Read only
</td>
<td>
- 상수 형태로 기술하는 문자열(예: "Hello")이 저장되는 메모리
</td>
<tr>
<td>
Read/Write
</td>
<td>
- 정적 변수나 전역변수들이 사용하는 메모리 <br>- 별도로 초기화하지 않아도 0으로 초기화됨 <br>- 자동 관리(할당 및 헤제)
</td>
</tr>
</table>

## 3. 자료의 추상화
- 어렵고 복잡한 문제를 풀 때, 단순화 시켜 문제를 해결하는 것을 자료 추상화<sup>data Abstraction</sup> 라고 한다
- 기본 개념은 자료<sup>data</sup>, 연산<sup>Operation</sup>, 자료형<sup>Data Type</sup>이 있다
	- 자료: 프로그램의 처리 대상이 되는 모든 것을 의미. 어떤 값<sup>Value</sup> 자체를 의미하기도 함
	- 연산: 어떤 일을 처리하는 과정으로 연산자를 이용하여 수행된다. ex) 덧셈 연산은 +연산자 이용
	- 자료형: 처리할 자료의 집합과 자료에 대해 수행 할 수 있는 연산자의 집합
		- 자료형을 정의 할 때는 자료형에 속하는 값과 연산자를 정의한다
		- ex) 정수 자료형의 집합 {.... -1, 0, 1 ....}이 되고 연산자는 {+, -, x, /, mod}가 된다
- 자료형에는 프로그래밍 언어에서 정의해서 제공하는 시스템 정의 자료형과 사용자가 정의해서 사용하는 사용자 정의 자료형이 있다
- 사용자 정의 자료형은 사용자가 필요에 따라 시스템 정의 자료형이나 기존에 정의해 놓은 다른 사용자 정의 자료형을 정의 한 것
- 자료형을 정의하려면 구체적으로 구현하기 전에 자료형에 대한 자료의 특성, 연산자, 연산자가 무엇을 수행하는지 등을 논리적으로 정의 해야함
- 이렇게 추상화하여 정의한 자료형을  추상 자료형<sup>ADT: Abstract Data Type</sup>이라 한다
- 추상 자료형은 구체적인 구현을 포함하지 않기 때문에 알고리즘 개발이 단순해진다
- 추상화는 이해를 위해 '무엇인지<sup>What</sup>를 논리적으로 정의 하는 것'이다
- 구체화는 사용을 위해 '어떻게 할지<sup>How</sup>를 실제적으로 표현하는 것'이다
<table>
<tr>
<th>
구분
</th>
<th>
자료
</th>
<th>
연산
</th>
</tr>
<tr>
<td>
추상화
</td>
<td>
추상 자료형
</td>
<td>
알고리즘 정의
</td>
</tr>
<tr>
<td>
구체화
</td>
<td>
자료형
</td>
<td>
프로그램 구현
</td>
</tr>
</table>

## 4. 알고리즘의 이해

- 알고리즘<sup>Algorithm</sup>은 문제를 해결하는 방법을 추상화 하여 단계적 절차를 논리적으로 기술해 놓은  명세사이다
- 문제 해결에 효과적인 알고리즘이 되려면 다음 조건을 만족해야한다
1. 입력<sup>Input</sup>: 알고리즘을 실행하는데 필요한 자료가 외부에서 입력되어야 한다
2. 출력<sup>Output</sup>: 알고리즘을 수행하고 나면 결과를 하나 이상 출력해야한다
3. 명확성<sup>Definiteness</sup>: 수행할 작업의 내용과 순서를 나타내는 알고리즘의 명령어는 명확하게 명세되어야한다
4. 유한성<sup>Finiteness</sup>: 알고리즘을 모두 수행하고 나면 반드시 종료되어야 한다
5. 효과성<sup>Effectiveness</sup>: 알고리즘의 모든 명령어는 기본적이며 실행할 수 있어야 한다
## 5. 알고리즘의 표현 방법

### 5-1. 알고리즘의 표현 방법

# 자료구조 구현을 위한 C 프로그래밍 기법

## 구조체 개념
- 구조체도 배열처럼 여러 데이터를 그룹으로 묶어 하나의 자료형으로 정의하고 사용하는 자료형이다
- 배열은 자료형이 같을 때만 그룹으로 묶을 수 있지만, 구조체는 서로 다른 그룹으로도 묶을 수 있다는 차이점이 있다
- 자료를 체계적으로 관리하려면 일정한 단위 형식으로 구성 하는 것을 레코드<sup>Record</sup>라고 한다
- 레코드를 구성하는 하위 항목을 필드<sup>Field</sup>라고 한다
- 레코드가 여러개 보이면 파일<sup>File</sup>이라고 한다
![[gujoche|1000]]
## 구조체 선언

- 구조체는 구조체형 이름, 자료향, 데이터 항목으로 구성된다
	- 구조체 이름은 구조체로 정의하는 새로운 자료형의 이름이다
	- 데이터 항목은 구조체를 구성하는 내부 변수들의 이름이다
	- 구조체의 데이터 항목은 배열의 배열 요소와 비슷하지만 자료형을 선언해야 한다는 차이점이 있다
- 구조체를 선언하는 방식과 사용하는 형식은 다음과 같다
![[jaryogujo|1000]]
구조체를 사용하는 방법은 다음과 같다:
1. 구조체형 선언 : 내부 구조를 정리한다
2. 구조체 변수 선언 : 구조체형에 따른 변수를 선언한다
3. 구조체 변수의 사용 : 내부 항목에 데이터를 저장하고 사용한다

직원 관리 프로그램에서 사용할 수 있는 구조체
```c
struct employee {
	char name[10];
	int year;
	int pay;
}
```

```c
struct employee Lee, Kim, Park;
```

구조체형과 구조체 변수
<table>
<tr style="background-color:gray; ">
<th style="color:black">
방법
</th>
<th style="color:black">
예
</th>
</tr>
<tr>
<td>
구조체형을 선언한 후에 구조체 변수 선언
</td>
<td>
struct employee {
    char name[10];
    int year;
    int pay;
};
struct employee
</td>
</tr>
<tr>
<td>
구조체형과 구조체 변수를 연결하여 선언
</td>
<td>
struct employee {
	char name[10];
	int year;
	int pay;
} Lee;
</td>
</tr>
<tr>
<td>
구조체형 이름을 생략하고 구조체 변수 이름만 선언
</td>
<td>
struct {
	char name[10];
	int year;
	int pay;
} Lee;
</td>
</tr>
</table>

# 시간 복잡도
1. $O(2N^2 + 3N + 4) → O(N^2)$
2. $O(log n +2) → O(log n)$
3. $O(n + 4) → O(n)$
4. $O(1) → O(1)$
# 리스트 - 코딩
```c
typedef struct ListNode(
	int data;
	struct ListNode* link;
)listnode;
typedef struct {
	listnode* head;
}headnode;
headnode* createlisthead(void){
	headnode* L;
	L = (headnode*)malloc(headnode);
	L -> head = NULL;
	return L;
} //head로 빈 리스트 생성
```

# 이중 연결 리스트 - 코딩

```c
typedef struct ListNode {
	int data;
	struct ListNode* rlink;
	struct ListNode* llink;
}listnode;
typedef struct {}
```