# 자료구조의 구분

1. 깊이 우선 검색
![[jaryogujo one]]
 - **기본 원리**: 시작 정점에서 출발하여 한 경로를 따라 갈 수 있는 데까지 계속 탐색하고, 더 이상 갈 곳이 없으면 가장 마지막에 만났던 갈림길로 되돌아가 다른 경로를 탐색한다.

 1. 1부터 시작한다고 한다면
 2. 1을 지나쳐 2 혹은 3으로 간다. 그리고 1을 스택영역(왼쪽 박스) 아래순서로 안에 넣는다
 3. 반복하다 길이 막히면 스택영역에서 맨 위에서 빼고 찾는다
2. 너비 우선 검색
![[jaryogujo one]]
- **기본 원리**: 시작 정점에서 출발하여 인접한 모든 정점을 먼저 탐색한 후, 그 다음 단계로 넘어가 인접한 정점들의 인접 정점을 탐색한다.

 1. 1부터 시작한다고 한다면 \[1]
 2. 1을 큐에서 꺼내고 인접한 2, 3을 추가한다 \[2, 3]
 3. 2를 큐에서 꺼내고 인접한 4, 5를 추가한다 \[3, 4, 5]
 4. 3을 큐에서 꺼내고 인접한 6, 7을 추가한다 \[4, 5, 6, 7]
 5. 4를 큐에서 꺼내고 인접한 8을 추가한다 \[5, 6, 7, 8]
 6. 5를 큐에서 꺼내고 인접한 8이 이미 큐에 있으므로 추가하지 않는다 \[6, 7, 8]
 7. 6을 큐에서 꺼내고 인접한 8이 이미 큐에 있으므로 추가하지 않는다 \[7, 8]
 8. 7을 큐에서 꺼내고 인접한 8이 이미 큐에 있으므로 추가하지 않는다 \[8]
 9. 8을 큐에서 꺼낸다 \[]

# 메모리의 분류와 특징
<table>
<tr>
<th colspan=3 >
분류
</th>
<th>
특징
</th>
</tr>
<tr>
<td colspan=3>
Stack
</td>
<td>
- 자동 변수이고 지역변수인 변수가 사용하는 메모리 영역<br> - 임시 메모리 성격 <br> - 크기가 작고(최대 1MB) 관리(할당 및 반환)가 자동으로 이루어짐
</td>
</tr>
<tr>
<td colspan=3>
Heap
</td>
<td>
- 동적 할당 가능한 자유 메모리 영역 <br>- 관리는 개발자가 직접(할당 및 해제 코드로 구현)
</td>
</tr>
<tr>
<td rowspan=3>
PE
</td>
<td colspan=2>
Text section
</td>
<td>
- 소스코드가 기계어로 번역되어 저장되는 메모리 영역 <br>- 읽기 전용
</td>
<tr>
<td rowspan=2>
Data section
</td>
<td>
Read only
</td>
<td>
- 상수 형태로 기술하는 문자열(예: "Hello")이 저장되는 메모리
</td>
<tr>
<td>
Read/Write
</td>
<td>
- 정적 변수나 전역변수들이 사용하는 메모리 <br>- 별도로 초기화하지 않아도 0으로 초기화됨 <br>- 자동 관리(할당 및 헤제)
</td>
</tr>
</table>

## 3. 자료의 추상화
- 어렵고 복잡한 문제를 풀 때, 단순화 시켜 문제를 해결하는 것을 자료 추상화<sup>data Abstraction</sup> 라고 한다
- 기본 개념은 자료<sup>data</sup>, 연산<sup>Operation</sup>, 자료형<sup>Data Type</sup>이 있다
	- 자료: 프로그램의 처리 대상이 되는 모든 것을 의미. 어떤 값<sup>Value</sup> 자체를 의미하기도 함
	- 연산: 어떤 일을 처리하는 과정으로 연산자를 이용하여 수행된다. ex) 덧셈 연산은 +연산자 이용
	- 자료형: 처리할 자료의 집합과 자료에 대해 수행 할 수 있는 연산자의 집합
		- 자료형을 정의 할 때는 자료형에 속하는 값과 연산자를 정의한다
		- ex) 정수 자료형의 집합 {.... -1, 0, 1 ....}이 되고 연산자는 {+, -, x, /, mod}가 된다
- 자료형에는 프로그래밍 언어에서 정의해서 제공하는 시스템 정의 자료형과 사용자가 정의해서 사용하는 사용자 정의 자료형이 있다
- 사용자 정의 자료형은 사용자가 필요에 따라 시스템 정의 자료형이나 기존에 정의해 놓은 다른 사용자 정의 자료형을 정의 한 것
- 자료형을 정의하려면 구체적으로 구현하기 전에 자료형에 대한 자료의 특성, 연산자, 연산자가 무엇을 수행하는지 등을 논리적으로 정의 해야함
- 이렇게 추상화하여 정의한 자료형을  추상 자료형<sup>ADT: Abstract Data Type</sup>이라 한다
- 추상 자료형은 구체적인 구현을 포함하지 않기 때문에 알고리즘 개발이 단순해진다
- 추상화는 이해를 위해 '무엇인지<sup>What</sup>를 논리적으로 정의 하는 것'이다
- 구체화는 사용을 위해 '어떻게 할지<sup>How</sup>를 실제적으로 표현하는 것'이다
<table>
<tr>
<th>
구분
</th>
<th>
자료
</th>
<th>
연산
</th>
</tr>
<tr>
<td>
추상화
</td>
<td>
추상 자료형
</td>
<td>
알고리즘 정의
</td>
</tr>
<tr>
<td>
구체화
</td>
<td>
자료형
</td>
<td>
프로그램 구현
</td>
</tr>
</table>

## 4. 알고리즘의 이해

- 알고리즘<sup>Algorithm</sup>은 문제를 해결하는 방법을 추상화 하여 단계적 절차를 논리적으로 기술해 놓은  명세사이다
- 문제 해결에 효과적인 알고리즘이 되려면 다음 조건을 만족해야한다
1. 입력<sup>Input</sup>: 알고리즘을 실행하는데 필요한 자료가 외부에서 입력되어야 한다
2. 출력<sup>Output</sup>: 알고리즘을 수행하고 나면 결과를 하나 이상 출력해야한다
3. 명확성<sup>Definiteness</sup>: 수행할 작업의 내용과 순서를 나타내는 알고리즘의 명령어는 명확하게 명세되어야한다
4. 유한성<sup>Finiteness</sup>: 알고리즘을 모두 수행하고 나면 반드시 종료되어야 한다
5. 효과성<sup>Effectiveness</sup>: 알고리즘의 모든 명령어는 기본적이며 실행할 수 있어야 한다
## 5. 알고리즘의 표현 방법

### 5-1. 알고리즘의 표현 방법

# 자료구조 구현을 위한 C 프로그래밍 기법

## 구조체 개념
- 구조체도 배열처럼 여러 데이터를 그룹으로 묶어 하나의 자료형으로 정의하고 사용하는 자료형이다
- 배열은 자료형이 같을 때만 그룹으로 묶을 수 있지만, 구조체는 서로 다른 그룹으로도 묶을 수 있다는 차이점이 있다
- 자료를 체계적으로 관리하려면 일정한 단위 형식으로 구성 하는 것을 레코드<sup>Record</sup>라고 한다
- 레코드를 구성하는 하위 항목을 필드<sup>Field</sup>라고 한다
- 레코드가 여러개 보이면 파일<sup>File</sup>이라고 한다
![[gujoche|1000]]
## 구조체 선언

- 구조체는 구조체형 이름, 자료향, 데이터 항목으로 구성된다
	- 구조체 이름은 구조체로 정의하는 새로운 자료형의 이름이다
	- 데이터 항목은 구조체를 구성하는 내부 변수들의 이름이다
	- 구조체의 데이터 항목은 배열의 배열 요소와 비슷하지만 자료형을 선언해야 한다는 차이점이 있다
- 구조체를 선언하는 방식과 사용하는 형식은 다음과 같다
![[jaryogujo|1000]]
구조체를 사용하는 방법은 다음과 같다:
1. 구조체형 선언 : 내부 구조를 정리한다
2. 구조체 변수 선언 : 구조체형에 따른 변수를 선언한다
3. 구조체 변수의 사용 : 내부 항목에 데이터를 저장하고 사용한다

직원 관리 프로그램에서 사용할 수 있는 구조체
```c
struct employee {
	char name[10];
	int year;
	int pay;
}
```

```c
struct employee Lee, Kim, Park;
```

구조체형과 구조체 변수
<table>
<tr style="background-color:gray; ">
<th style="color:black">
방법
</th>
<th style="color:black">
예
</th>
</tr>
<tr>
<td>
구조체형을 선언한 후에 구조체 변수 선언
</td>
<td>
struct employee {
    char name[10];
    int year;
    int pay;
};
struct employee
</td>
</tr>
<tr>
<td>
구조체형과 구조체 변수를 연결하여 선언
</td>
<td>
struct employee {
	char name[10];
	int year;
	int pay;
} Lee;
</td>
</tr>
<tr>
<td>
구조체형 이름을 생략하고 구조체 변수 이름만 선언
</td>
<td>
struct {
	char name[10];
	int year;
	int pay;
} Lee;
</td>
</tr>
</table>

# 시간 복잡도
1. $O(2N^2 + 3N + 4) → O(N^2)$
2. $O(log n +2) → O(log_n)$
3. $O(n + 4) → O(n)$
4. $O(1) → O(1)$
# 리스트 - 코딩
```c
typedef struct ListNode(
	int data;
	struct ListNode* link;
)listnode;
typedef struct {
	listnode* head;
}headnode;
headnode* createlisthead(void){
	headnode* L;
	L = (headnode*)malloc(headnode);
	L -> head = NULL;
	return L;
} //head로 빈 리스트 생성
```

# 이중 연결 리스트 - 코딩

```c
typedef struct ListNode {
	int data;
	struct ListNode* rlink;
	struct ListNode* llink;
} listnode;

typedef struct {
	listnode* head;
} headnode;

headnode* createlisthead(void) {
	headnode* L;
	L = (headnode*)malloc(sizeof(headnode));
	L->head = NULL;
	return L;
} //head로 빈 리스트 설정

void bb(headnode* L, int data) {
	listnode* newNode = (listnode*)malloc(sizeof(listnode));
	newNode->data = data;
	newNode->rlink = L->head
	newNode->llink = NULL
	if(L->llink != NULL){
		L->head->llink = newNode;
	}
	L->head = newNode
}
```


# 정렬

|            |                                                                                                                                                                                                                                                                                                                                                                               |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 삽입정렬의 방식   | 자신보다 작은 인덱스들을 자신과 비교하여 작을수록 앞 인덱스로 넘기는 방식                                                                                                                                                                                                                                                                                                                                     |
| 삽입정렬의 수행방법 | 1. 먼저 인덱스 0부터 마지막 인덱스까지 순회를 실행한다.  <br>2. 순회하는 과정에서, 자신 보다 인덱스가 -1 작은 인덱스와 비교하여 만약 자신이 더 작다면 인덱스 위치를 교환한다  <br>3. 2과정을 자리 교환 과정이 없을때 까지 반복한다(= 자신보다 작은 값이 나올때 까지(순회 발생))                                                                                                                                                                                                      |
| 삽입정렬의 장점   | 단순해 구현이 쉽다, 이미 정렬된 배열이라면 정렬이 빠르다                                                                                                                                                                                                                                                                                                                                              |
| 삽입정렬의 단점   | 인덱스를 계속 순회하기 때문에 순회가 잦고, 인덱스의 값 변화가 잦다. 시간 복잡도가 O(n^2)이므로 상대적으로 크다                                                                                                                                                                                                                                                                                                            |
| 퀵 정렬의 방식   | 한 값을 기준으로 그 이상인 것은 오른쪽, 이하인 것은 왼쪽으로 보내 그 값의 위치를 맞추고,  <br>그 값의 왼쪽을 잘라 퀵 정렬을 실행하고, 그 값의 오른쪽을 잘라 퀵 정렬을 실행하는 방식                                                                                                                                                                                                                                                                  |
| 퀵 정렬의 수행방법 | 1. 기준 배열의 맨 왼쪽의 인덱스를 pivot이라고 하고 맨 오른쪽의 인덱스를 com이라고 하겠다.  <br>2. 만약 arr[pivot]과 arr[com]의 순서가 맞지 않다면, 위치를 바꾼다. (pivot과 com도 변경된다)  <br>3. 만약 com < pivot이라면, com을 1 증가시키고 3번을 다시 실행한다.  <br>4. 만약 pivot < com이라면, com을 1 감소시키고 3번을 다시 실행한다.  <br>5. 만약 pivot == com이라면, 그 숫자를 기준으로 하여 왼쪽 배열과 오른쪽 배열으로 나눈다.  <br>6. 왼쪽 배열을 기준으로 1번을 다시 실행한다.  <br>7. 오른쪽 배열을 기준으로 1번을 다시 실행한다. |
| 퀵 정렬의 장점   | 속도가 빠르다 (평균 속도가 O(NlogN)), O(logn)만큼의 메모리를 필요로 한다,                                                                                                                                                                                                                                                                                                                            |
| 퀵 정렬의 단점   | 정렬된 리스트에 대해서는 퀵정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.  <br>불안정 정렬이므로 키 값이 같은 원소에 대해 순서가 같음을 보장할 수 없다.  <br>구현부가 이해가 어려울 수 있을 정도로 알고리즘이 복잡하다                                                                                                                                                                                                                                       |
## 선택 정렬
- 첫 번째 원소부터 정렬되는 방식
### 선택 정렬 구현
```c
void SelectionSort(int a[], int size){
	int i, j, t, min, temp;
	
	for(i = 0; i < size - 1; i++){
		min = i;
		for(j = i + 1; j < size; j++){
			if(a[j] < a[min]) min = j;
		}
		temp = a[i];
		a[i] = a[min];
		a[min] = temp;
		printf("\n%d단계 : ", i + 1);
		for(t = 0; t < size; t++) printf("%3d ", a[t]);
	}
}
```
## 버블 정렬 구현
```c
void bubbleSort(int a[], int size){
	int i, j, temp;
	
	for(i = size - 1; i > 0; i--) {
		printf("\n %d단계>>", size - i);
		for(j = 0; j < i; j++) {
			if(a[j] > a[j + 1]) {
				temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temmp;
			}
			printf("\n\t");
			for(t = 0; t < size; t++) printf("%3d ", a[t])
		}
	}
}
```

## 삽입 정렬 구현

```c
void insertionSort(int a[], int size){
	int 
}
```

세 가지 정렬 알고리즘인 **버블 정렬**, **선택 정렬**, **삽입 정렬**을 외우는 것이 처음에는 혼란스러울 수 있습니다. 각각의 알고리즘이 어떻게 동작하는지 이해하면 구분하는 데 도움이 될 것입니다. 아래에서 각 정렬 알고리즘의 개념과 동작 방식을 한국어로 간단히 설명드리겠습니다.

---

### 1. **버블 정렬 (Bubble Sort)**

- **개념**: 인접한 두 요소를 비교하여 정렬하는 방식입니다. 큰 값이 점점 위로 '거품처럼' 올라가는 모습에서 이름이 유래되었습니다.
    
- **동작 방식**:
    
    1. 배열의 끝에서부터 시작하여 인접한 두 요소를 비교합니다.
    2. 앞의 요소가 뒤의 요소보다 크면 두 요소를 교환합니다.
    3. 이 과정을 반복하면 가장 큰 값이 맨 끝으로 이동합니다.
    4. 배열의 크기를 하나 줄이고 다시 반복하여 정렬을 완료합니다.
- **특징**:
    
    - 구현이 간단하지만 효율성이 낮아 큰 데이터에는 부적합합니다.
    - 최악의 경우 시간 복잡도는 O(n²)입니다.
- **코드 이해하기**:
    
    c
    
    코드 복사
    
```c
for(i = size - 1; i > 0; i--){
    for(j = 0; j < i;  j++){
        if(a[j] > a[j+1]){
            // 교환
        }
    }
}

```
    
    - `i`는 각 단계마다 비교할 범위를 줄여 나갑니다.
    - `j`는 인접한 요소를 비교합니다.

---

### 2. **선택 정렬 (Selection Sort)**

- **개념**: 현재 위치에서 가장 작은(또는 가장 큰) 요소를 선택하여 앞으로 이동시키는 방식입니다.
    
- **동작 방식**:
    
    1. 배열의 처음부터 끝까지 순회하며 최솟값을 찾습니다.
    2. 찾은 최솟값을 현재 위치의 요소와 교환합니다.
    3. 다음 위치로 이동하여 반복합니다.
- **특징**:
    
    - 구현이 비교적 간단하며, 데이터 이동 횟수가 적습니다.
    - 최악의 경우 시간 복잡도는 O(n²)입니다.
- **코드 이해하기**:
    
    c
    
    코드 복사
    
  ```c
for(i = 0; i < size; i++) {
    min = i;
    for(j = i + 1; j < size; j++) {
        if(a[min] > a[j]) min = j;
    }
    // 교환
}
	```
    
    - `i`는 현재 선택할 위치를 나타냅니다.
    - `min`은 현재 위치부터 끝까지의 최솟값의 인덱스를 저장합니다.

---

### 3. **삽입 정렬 (Insertion Sort)**

- **개념**: 이미 정렬된 부분과 정렬되지 않은 부분으로 배열을 나누고, 정렬되지 않은 부분의 요소를 하나씩 정렬된 부분에 '삽입'하는 방식입니다.
    
- **동작 방식**:
    
    1. 두 번째 요소부터 시작하여 현재 요소를 이전의 정렬된 요소들과 비교합니다.
    2. 현재 요소보다 큰 요소는 한 칸씩 뒤로 이동합니다.
    3. 현재 요소를 적절한 위치에 삽입합니다.
    4. 모든 요소가 정렬될 때까지 반복합니다.
- **특징**:
    
    - 거의 정렬된 데이터에 대해 효율적입니다.
    - 최악의 경우 시간 복잡도는 O(n²)이지만, 최선의 경우 O(n)입니다.
- **코드 이해하기**:
    
    c
    
    코드 복사
```c
for (i = 1; i < size; i++) {
    temp = a[i];
    j = i - 1;
    while (j >= 0 && a[j] > temp) {
        a[j + 1] = a[j];
        j--;
    }
    a[j + 1] = temp;
}

```
    
    - `i`는 현재 삽입할 요소의 인덱스입니다.
    - `temp`는 삽입할 값을 임시로 저장합니다.
    - `j`는 이미 정렬된 부분을 탐색하면서 삽입 위치를 찾습니다.

---

### **정리 및 기억 팁**

1. **버블 정렬**:
    
    - **키워드**: "거품", "인접 비교", "큰 값이 끝으로 이동"
    - **기억법**: 물속에서 거품이 위로 올라가듯이 큰 값이 천천히 배열의 끝으로 올라간다고 생각하세요.
2. **선택 정렬**:
    
    - **키워드**: "선택", "최솟값 찾기", "교환"
    - **기억법**: 매 단계마다 가장 작은 값을 선택하여 앞으로 이동시키는 과정이라고 생각하세요.
3. **삽입 정렬**:
    
    - **키워드**: "삽입", "정렬된 부분", "올바른 위치 찾기"
    - **기억법**: 카드를 손에 들고 하나씩 올바른 위치에 삽입하는 것과 비슷하다고 생각하세요.

각 알고리즘의 **주요 동작 방식**과 **키워드**를 연상하면서 외우면 구분하기 쉬울 것입니다. 또한, 직접 손으로 간단한 배열을 사용하여 각 정렬 과정을 시뮬레이션해보면 이해와 기억에 큰 도움이 됩니다.

---

추가적으로, 각 정렬 알고리즘의 시간 복잡도와 공간 복잡도를 함께 공부하면 언제 어떤 알고리즘을 사용하는 것이 효율적인지 판단하는 데 도움이 됩니다.

- **버블 정렬**: 시간 복잡도 O(n²), 공간 복잡도 O(1)
- **선택 정렬**: 시간 복잡도 O(n²), 공간 복잡도 O(1)
- **삽입 정렬**: 시간 복잡도 O(n²) (최악), O(n) (최선), 공간 복잡도 O(1)
### **1. 버블 정렬 (Bubble Sort)**

c

코드 복사

```c
void bubbleSort(int a[], int size) {  // 배열 a와 크기 size를 매개변수로 받는 버블 정렬 함수
    int i, j, t, temp;  // 반복문 제어 변수 i, j와 출력용 t, 임시 변수 temp 선언

    for(i = size - 1; i > 0; i--) {  // 배열의 끝부터 시작해서 한 단계씩 줄여가며 반복
        printf("\n %d단계>>", size - i);  // 현재 단계 출력
        for(j = 0; j < i; j++) {  // 배열의 처음부터 i까지 반복하면서 인접한 두 요소를 비교
            if(a[j] > a[j+1]) {  // 현재 요소가 다음 요소보다 크면
                temp = a[j];     // 두 요소를 교환
                a[j] = a[j+1];
                a[j + 1] = temp;
            }
            printf("\n\t");  // 비교가 끝날 때마다 줄바꿈
        }
        for(t = 0; t < size; t++) printf("%3d ", a[t]);  // 배열의 현재 상태를 출력
    }
}


```

### **2. 선택 정렬 (Selection Sort)**

c



```c
void selectionSort(int a[], int size) {  // 배열 a와 크기 size를 매개변수로 받는 선택 정렬 함수
    int i, j, t, min, temp;  // 반복문 제어 변수 i, j, 출력용 t, 최소값 인덱스 min, 임시 변수 temp 선언

    for(i = 0; i < size; i++) {  // 배열의 처음부터 끝까지 반복
        min = i;  // 현재 위치를 최소값 인덱스로 설정
        printf("\n %d : ", i + 1);  // 현재 단계 출력
        for(j = i + 1; j < size; j++) {  // 현재 위치 다음부터 끝까지 반복하여 최소값 탐색
            if(a[min] > a[j]) min = j;  // 현재 최소값보다 작은 값이 있으면 min을 갱신
        }
        temp = a[i];     // 최소값을 현재 위치와 교환
        a[i] = a[min];
        a[min] = temp;
        for(t = 0; t < size; t++) printf("%d ", a[t]);  // 배열의 현재 상태를 출력
    }
}

```

### **3. 삽입 정렬 (Insertion Sort)**

c

코드 복사

```c
void insertionSort(int a[], int size) {  // 배열 a와 크기 size를 매개변수로 받는 삽입 정렬 함수
    int i, j, t, temp;  // 반복문 제어 변수 i, j, 출력용 t, 임시 변수 temp 선언

    for (i = 1; i < size; i++) {  // 두 번째 요소부터 시작하여 배열의 끝까지 반복
        temp = a[i];  // 현재 요소를 임시 변수에 저장
        j = i - 1;    // 정렬된 부분의 끝에서부터 비교를 시작
        printf("\n %d : ", i);  // 현재 단계 출력
        while (j >= 0 && a[j] > temp) {  // 정렬된 부분에서 현재 요소보다 큰 값을 찾으면
            a[j + 1] = a[j];  // 큰 값을 오른쪽으로 이동
            j--;  // 왼쪽으로 한 칸 이동하여 다음 요소와 비교
        }
        a[j + 1] = temp;  // 적절한 위치에 현재 요소 삽입
        for (t = 0; t < size; t++) printf("%d ", a[t]);  // 배열의 현재 상태를 출력
    }
}

```

# 그래프
## 무방향 그래프

![[Pasted image 20241204134829.png]]
방향이 없는 그래프
## 방향 그래프
![[Pasted image 20241204134925.png]]
방향이 있는 그래프

## 완전 그래프
![[Pasted image 20241204134951.png]]
모두 이어져 있고, 방향그래프인 경우에는 양방향으로 이어져 있다

## 부분그래프
- 원래의 그래프에서 정점이나 간선을 일부만 제외하여 만든 그래프
- 그래프 G와 부분 그래프 G'의 관계 $V(G')\subseteq V(G), E(G')\subseteq E(G)$
- 그래프 G1에 대한 부분 그래프의 
- ![[Pasted image 20241204135428.png]]
## 가중 그래프, 네트워크
- 정점을 연결하는 간선에 가중치를 할당한 그래프
![[Pasted image 20241204135512.png]]
## 그래프의 구조
- 차수 - 정점에 부속되어 있는 간선의 수
	- 그림\[그림 8-8]의 무방향 그래프 G1에서 정점 A의 차수는 2, 정점 B의 차수는 3
	- 방향 그래프의 정점의 차수 = 진입차수 + 진출차수
		- 방향 그래프의 진입차수: 정점을 머리로 하는 간선의 수
		- 방향 그래프의 진출차수: 정점을 꼬리로 하는 간선의 수
		- 그림\[그림 8-8]의 방향 그래프 G3에서 정점 B의 진입차수 1, 진출차수는 2
		  정점 B의 전체 차수는 (진입차수 + 진출차수) 이므로 3임
- 경로
	- 그래프에서 간선을 따라 갈 수 있는 길을 순서대로 나열한 것 즉, 정점 Vi에서 Vj까지 간선으로 연결된 정점을 순서대로 나열한 리스트
- 단순경로
	- 모두 다른 정점으로 구성된 경로
		- 그래프 G1에서 정점 A에서 정점 C까지의 경로 A-B-C는 단순경로 이고, 
		  경로 A-B-D-A-B-C는 단순 경로가 아님
  - 사이클
	  - 단순경로 중에서 경로의 시작 정점과 마지막 정점이 같은 경로
		  - 그래프 G1에서 단순경로 A-B-C-D-A와 그래프 G4에서 단순경로 A-b-A는 사이클이 됨
  - DAG
	  - 방향 그래프이면서 사이클이 없는 그래프
  - 연결 그래프
	  - 서로 다른 모든 쌍의 정점들 사이에 경로가 있는 그래프 즉, 떨어져 있는 정점이 없는 그래프
	  - 그래프에서 두 정점 V<sub>1</sub>에서 V<sub>3</sub>까지의 경로가 있으면 정점 V<sub>1</sub>와 V<sub>3</sub>가 연결 되었다고 함, 트리는 사이클이 없는 연결 그래프
	  - 단절 그래프 - 연결되지 않은 정점이 있는 그래프
### 순차 자료구조를 이용한 그래프의 구현 : 인접 행렬
- 행렬에 대한 2차원 배열을 사용하는 순차 자료구조 방법
- 그래프의 두 정점을 연결한 간선의 유무를 행렬로 저장
	- n개의 정점을 가진 그래프: n x n 정방행렬
	- 행렬의 행번호와 열번호: 그래프의 정점
	- 행렬 값: 두 정점이 인접되어있으면 1, 인접되어있지않으면 0
- 무방향 그래프의 인접 행렬
	- 행 i의 합 = 열 i의 합 = 정점 i의 차수
- 방향 그래프의 인접 행렬
	- 행 i의 합 = 정점 i의 진출차수
	- 열 i의 합 = 정점 i의 진입차수