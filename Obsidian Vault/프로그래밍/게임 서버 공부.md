즐 겁 다 !
왜 한국어로 되있는게 별로 없지
흑ㅎ그

# 사용 언어

여러개의 언어로 사용되지만 주로  PHP, Ruby, Python, .NET, Java or JS 등을 사용한다
각자의 장단점이 있다

| 언어                       | 장점                                                              | 단점                                                |
| ------------------------ | --------------------------------------------------------------- | ------------------------------------------------- |
| **C++**                  | - 높은 성능과 효율성  <br>- 하드웨어 제어에 강함  <br>- 많은 게임 엔진과 호환             | - 복잡한 메모리 관리  <br>- 학습 곡선이 가파름                    |
| **Java**                 | - 플랫폼 독립성 (JVM 기반)  <br>- 풍부한 라이브러리와 프레임워크  <br>- 안정적인 멀티스레딩 지원 | - 상대적으로 낮은 실행 속도  <br>- 메모리 사용량이 많을 수 있음          |
| **C#**                   | - Unity와의 높은 호환성  <br>- 생산성이 높고 쉬운 문법  <br>- 강력한 .NET 생태계       | - 특정 플랫폼에 종속적일 수 있음  <br>- 네이티브 성능이 C++보다 낮을 수 있음 |
| **Go**                   | - 간결한 문법과 빠른 컴파일 속도  <br>- 효율적인 동시성 처리  <br>- 쉬운 배포             | - 상대적으로 제한된 라이브러리 생태계  <br>- 게임 서버 특화 기능 부족       |
| **JavaScript (Node.js)** | - 비동기 I/O 처리에 강함  <br>- 빠른 개발 속도  <br>- 풍부한 패키지 생태계             | - 단일 스레드 모델로 인한 CPU 집약적 작업에 부적합  <br>- 콜백 지옥 가능성  |
| **Python**               | - 쉬운 학습과 빠른 프로토타이핑  <br>- 풍부한 라이브러리  <br>- 높은 생산성               | - 낮은 실행 속도  <br>- 대규모 서버에 적합하지 않을 수 있음            |
| **Rust**                 | - 메모리 안전성과 높은 성능 <br>- 현대적인 문법과 기능  <br>- 병행성에 강함               | - 비교적 새로운 언어로 학습 자료가 적을 수 있음  <br>- 컴파일 시간이 김     |
그렇다나 뭐라나..

# TCP와 UDP
## TCP

### TCP가 무엇인지
주로 게임의 채팅, 로그인 서버등을 맡는다. TCP는 두 호스트가 연결을 확인하고 데이터를 교환 할 수 있게 만든다.
이 통신 중, TCP는 오류 검사 매커니즘과 손실된 데이터를 재전송하는 시스템을 제공하여 데이터가 손상되거나 순서가 맞지 않게 수신되지 않도록 된다
네트워크 통신 중, 네트워크 리소스를 효율적으로 처리하기 위해 TCP는 흐름 제어, 혼잡 제어를 구현하고, 호스트가 연결의 처리량을 동적으로 조정할 수 있게 한다

주요 특징들을 정리하자면 :
- 연결 지향적: 통신이 시작하기 전에 연결을 설정하고 통신이 끝나면 연결을 종료한다
- 신뢰성: 위에 상술한 이유로, 손상되거나 순서가 맞지 않다면 재전송으로 정확하게 전달한다
- 흐름 제어: 송신자와 수신자간의 전송 속도를 조정하여 네트워크가 혼잡한 것을 방지 할 수 있다.
- 혼잡 제어: 네트워크 상태에 따라 전송속도를 적절히 조절하여 혼잡을 방지 할 수 있다

### 장단점
장점:
1. 신뢰성: 패킷 손실이나 순서 변경 없이 데이터가 정확히 전송된다. 채팅메시지, 게임 상태 업데이트에 유리함
2. 데이터 무결성: 데이터가 손상되지 않고 전달 되므로 게임로직의 일관성을 유지 할 수 있다
3. 연결 관리: 연결을 통해 클라이언트와 서버간에 지속적으로 연결 가능

단점:
1. 지연 시간(Latency): 데이터 전송 전에 연결 설정 및 확인 과정이 필요하여 지연 시간이 늘어 날 수 있다
2. 오버헤드[^1] : 신뢰성을 보장하기 위해 추가적인 확인 정보와 제어 메시지가 필요하여 네트워크 오버헤드가 발생한다
3. 혼잡관리: 혼잡 제어 메커니즘으로 인해 데이터 전송 속도가 변동될 수 있다

[^1]: 어떤 처리를 하기 위해 들어가는 간접적인 시간 · 메모리 등을 말한다

### TCP를 게임서버에 적용시키는 방법
#### 서버-클라이언트 아키텍쳐 설계
- 서버: 중앙에서 서버 상태를 관리하여 클라이언트 요청을 처리 할 수 있다
- 클라이언트: 사용자의 입력을 서버에 전송하고, 서버로부터 게임 상태를 수신하여 화면에 표시한다
#### 소켓 프로그래밍
TCP 통신을 구현하기 위해 소켓 프로그래밍을 사용한다
단계 예시: 
  서버
 1. 소켓 생성
 2. 주소 바인딩[^2]
 3. 연결 대기
 4. 연결 수락
 5. 데이터 송수신
 6. 연결 종료

  클라이언트:
  1. 소켓 생성
  2. 서버 연결
  3. 데이터 송수신
  4. 연결 종료

[^2]: 논리적 주소를 물리적 주소로 바꾸는 것 
#### 멀티스레딩 및 비동기 처리
게임서버는 여러 클라이언트와 동시에 통신해야 하므로, 멀티스레딩이나 비동기 I/O작업[^3]을 처리하여 자원사용을 최적화 한다
- 멀티스레딩: 각 클라이언트의 연결을 별도의 스레드에서 처리하여 동시성을 확보한다
- 비동기 I/O: 단일 스레드에서 비동기적으로 여러 클라이언트의 I/O 작업을 처리하여 자원사용을 최적화 한다.

[^3]: 사람에게 입력을 받아 출력하는 것

#### 데이터 직렬화 및 프로토콜 설계

게임서버와 클라이언트 간의 데이터 교환을 효율적으로 하기 위해, 데이터 직렬화 방법과 통신 프로토콜을 설계 해야한다
- 직렬화: 데이터를 바이트 스트림[^4]으로 변환하여 전송한다
- 프로토콜: 데이터 구조와 통신 규칙을 정의한다 ex) 메시지의 타입, 길이, 페이로드[^5]등

[^4]: 바이트 단위로 데이터를 전송하는 것
[^5]: 전송되는 순수한 데이터, 데이터와 함께 전송되는 헤더, 메타데이터 등은 제외한다

#### 에러 처리 및 재연결 로직
TCP 통신중 일어날 수 있는 에러 상황을 처리하고, 클라이언트가 예기치않게 연결이 끊어진 경우 재연결 로직을 구현해야 한다

### 최적화 및 성능 향상 팁
#### 패킷[^6] 크기 최소화
[^6]: 네트워크가 전달하는 데이터의 형식화된 블록

전송하는 데이터의 크기를 최소화하여 네트워크 대역폭을 효율적으로 사용한다. 불필요한 데이터를 제거하고, 압축 기법을 이용할 수 있다
#### 패킷 병합

여러 개의 작은 패킷을 하나로 병합하여 전송함으로써 네트워크 오버헤드를 줄일 수 있다

#### Keep-Alive 설정

TCP연결이 일정시간 동안 유지되지 않을 경우 자동으로 연결을 종료하는 Keep-Alive설정을 통해 리소스를 효율적으로 관리할 수 있다

#### 쓰레드 풀 사용

멀티스레딩 시, 쓰레드 풀[^7]을 사용하여 스레드 생성 및 소멸에 따른 오버헤드를 줄이고 성능을 향상시킬 수 있다

[^7]: 동시에 실행되는 작업을 관리하는 데 사용되는 메커니즘
#### 비동기 I/O 활용

비동기 I/O를 활용하여 블로킹 없이 다수의 클라이언트를 효율적으로 처리 가능하다
### 보안 고려사항
#### 데이터 암호화
중간에 데이터가 탈취되지 않도록 SSL/TLS[^8]를 사용하여 데이터 전송을 암호화한다

[^8]: SSL은 Secure Sockets Layer 즉, 보안 소켓 계층, TLS는 Transport Layer Security 즉, 전송 계층 보안을 의미
#### 인증 및 권한 부여
클라이언트의 인증 절차를 통해 허가되지 않은 접근 을 차단한다
#### 입력 검증
클라이언트로부터 수신된 데이터를 철저히 검증하여 악의적인 공격을 방지합니다.
### TCP 체크섬
#### TCP 체크섬이란?
TCP 헤더의 16비트 필드로 오류 검사를 수행하는데 사용된다. TCP 스택은 전송된 데이터에 대한 체크섬 값을 계산하여 데이터와 함께 계산된 값과 비교한다. 두 계산 값이 일치하면 전송 오류가 없는 것으로 판단하고, 만약 일치하지 않다면 TCP는 수신된 데이터의 변경을 감지하고 수신기는 손실되거나 손상된 데이터 패킷의 재전송을 요청한다.

기능을 요약하자면:
1. 오류 검출: 전송 중 발생 할 수 있는 비트 오류, 데이터 수신등을 감지한다
2. 데이터 무결성 보장: 데이터가 송신자에서 수신자까지 전달되는 동안 변경되지 않았음을 보장한다
3. 신뢰성 향상: 신뢰할 수 없는 네트워크 환경에서도 데이터의 정확한 전달을 보장한다
##### 체크섬의 중요성

서버 사이드 게임 개발에서 체크섬은 여러 가지 측면에서 중요합니다:

- **데이터 무결성 보장**: 게임 클라이언트와 서버 간의 데이터 전송 시, 데이터가 손상되지 않았는지 확인할 수 있습니다.
- **보안 강화**: 체크섬을 통해 데이터 변조를 탐지할 수 있어, 해커의 공격을 어느 정도 방어할 수 있습니다.
- **디버깅 및 문제 해결**: 데이터 전송 오류를 신속하게 감지하고 문제를 해결하는 데 도움이 됩니다.

##### 체크섬의 종류

체크섬에는 여러 종류가 있으며, 각각의 특성과 용도가 다릅니다. 주요 체크섬 알고리즘은 다음과 같습니다:

###### 단순 체크섬 (Simple Checksum)

가장 기본적인 형태로, 데이터의 모든 바이트 값을 단순히 합산하여 특정 값으로 만드는 방법이다. 구현이 간단하지만 오류 검출 능력이 낮다.

###### 순환 중복 검사 (CRC, Cyclic Redundancy Check)

더 복잡한 알고리즘으로, 데이터의 다항식을 사용하여 계산된다. CRC는 단순 체크섬보다 높은 오류 검출 능력을 가지고 있으며, 네트워크 통신에서 널리 사용된다.

###### 해시 기반 체크섬 (Hash-based Checksum)

MD5, SHA-1, SHA-256 등과 같은 해시 알고리즘을 사용하여 데이터의 고유한 해시 값을 생성한다. 높은 보안성을 제공하지만, 계산 비용이 상대적으로 높다.

###### 해시 함수 vs 체크섬

해시 함수는 체크섬보다 더 복잡한 연산을 수행하여 데이터의 무결성을 확인하고, 보안성을 강화합니다. 그러나 체크섬은 속도와 간단함이 장점이다.

##### 게임 개발에서의 체크섬 활용
###### 데이터 전송 무결성 확인
클라이언트와 서버간에 패킷 전송시, 체크섬을 사용하여 데이터가 손상되지않고 정확하게 전달 되었는지 확인이 가능하다
###### 게임 데이터 검증
게임 내에서 중요한 데이터(ex: Player State, Game State etc..)의 무결성을 위해 체크섬 활용 가능
###### 보안 강화
체크섬을 통해 데이터 변조를 탐지하고, 해킹 시도를 어느 정도 방어할 수 있다.
### 세그먼트 구조
TCP는 **세그먼트화**라는 방법을 사용하여 데이터 전송을 관리한다. 이 접근 방식에서 TCP는 데이터 스트림을 "세그먼트"라고 하는 더 작은 부분으로 나눈다. 그런 다음 이러한 세그먼트들을 인터넷을 통해 독립적으로 전송한다. 기본 TCP 세그먼트는 헤더와 데이터 섹션으로 나뉘는데, 헤더에는 소스 포트, 대상 포트, 시퀀스 번호, 확인 번호, 데이터 오프셋, 예약 섹션, 제어 비트, 창, 체크섬, 긴급 포인터 및 옵션과 같은 다양한 필드로 포함된다. 나머지 세그먼트는 TCP가 전송하는 데이터로 채워진다.

#### 주요 개념
- 패킷(Packet): 네트워크를 통해 전송되는 데이터의 기본 단위
- 헤더(Header): 패킷의 메타데이터를 포함하는 부분
- 페이로드(Payload): 실제 전송되는 데이터
#### 중요한 이유?
- 효율적인 데이터 전송: 불필요한 데이터를 줄이고 필요한 정보만 전송하여 대역폭을 절약한다.
- 데이터 무결성 보장: 전송 중 데이터 손상이나 오류를 감지하고 복구할 수 있다.
- 보안 강화: 데이터 변조나 도청을 방지하기 위한 보안 메커니즘을 포함할 수 있다.
- 확장성: 새로운 기능이나 데이터 유형을 쉽게 추가할 수 있는 유연성을 제공한다.
#### 세그먼트 구조 설계 원칙
##### 명확한 정의
세그먼트의 각 필드와 그 역할을 명확히 정의하여 클라이언트와 서버 모두 동일하게 해석 할 수 있게 한다
##### 확장성
새로운 기능이나 데이터유형을 쉽게 추가할 수 있도록 유연한 구조를 설계한다. ex) 버전 필드를 포함하여 구조 변경시 호환성 유지

##### 효율성
데이터 전송의 효율성을 높이기 위해 필요한 정보만 기입 해야한다. 데이터를 압축, 최적화 하여 저장한다

##### 보안
데이터의 기밀성과 무결성을 위한 보안 메커니즘을 포함해야 한다
ex) 암호화, 인증필드등

#### 직렬화와 역직렬화
세그먼트 구조는 바이너리 형태로 전송되지만, 다양한 프로그래밍 언어에서 호환되도록 데이터를 직렬화<sup>serialize</sup>하고 역직렬화<sup>deserialize</sup>해야 한다.
##### 직렬화
객체나 데이터를 일련의 바이트로 만드는 과정을 말한다. 
일반적인 데이터 포맷은 다음과 같다:

| 데이터 포맷          | 설명                        |
| --------------- | ------------------------- |
| JSON            | 가독성이 높고 인간이 읽기 쉬운 방식      |
| Protocal Buffer | 구글에서 개발한 효율적인 바이너리 직렬화 포맷 |
| MessagePack     | 이진 데이터 직렬화를 지원하는 포맷       |
| FlatBuffers     | 빠른 직렬화와 역 직렬화를 지원하는 포맷    |
##### 역직렬화
직렬화된 데이터를 원래의 객체나 데이터 구조로 복원하는 과정이다. 클라이언트와 서버는 동일한 직렬화 포맷을 이용해야 한다

#### 다양한 데이터 처리
게임 서버는 다양한 유형의 데이터를 주고받는다. 이를 효과적으로 처리하기 위해 세그먼트 구조를 유연하게 설계해야한다
##### 플레이어 동작
플레이어의 움직임, 공격, 아이템 사용 등의 동작을 전송할 때는 해당 동작에 맞는 정보(ex: 위치, 방향, 동작 유형)을 페이로드에 포함시킨다.
##### 게임 상태 업데이트
게임의 현재 상태, ex) NPC 위치, 아이템 상태, 퀘스트 정보들을 주기적으로 업데이트 할 때 사용된다.
##### 채팅 메시지
플레이어 간에 채팅 메시지를 전송할 때는 메시지 내용과 발신자 정보를 포함시킨다
##### 시스템 메시지
서버의 알림, 메시지, 공지사항등을 전송할 때에 사용된다
#### 버전 관리 및 확장성
다음은 버전 관리 및 확장성의 팁들이다. 이미 알고 있다면 다음 챕터로
1. 버전 필드 추가
2. 유연한 필드 처리
3. 하위 호환성
### MSS란 무엇인가?
최대 세그먼트 크기<sup>Meximum Segment Size, MSS</sup>는 TCP 프로토콜로 한 번에 전송할 수 있는 최대 패킷 크기(MTU: Maximum Transmission Unit)를 고려하여 결정한다. MSS는 주로 TCP 연결 설정 시 협상되며, 데이터 전송의 효율성과 신뢰성을 유지하는데 중요한 역할을 한다

주요 개념:
- MSS(Meximum Segment Size): TCP 세그먼트의 데이터 부분에서 전송 할 수 있는 최대 바이트 수
- MTU(Meximum Transmission Unit): 네트워크 계층에서 사용할 수 있는 최대 크기
- 헤더 오버헤드: TCP/IP 헤더가 차지하는 바이트 수 (일반적으로는 TCP는 20바이트, IP는 20바이트)
#### 중요성
- 패킷 단편화 방지: MSS가 MTU보다 작게 설정되면, 네트워크 상에서 패킷이 분할되는 것을 방지해서 전송 지연과 오류를 방지한다
- 전송 효율성 향상: 최적화된 MSS는 전송 중 오버헤드를 최소화하여 데이터 전송의 효율을 높인다
- 지연시간 감소: 패킷이 적절한 크기로 전송되면, 지연시간이 줄어들고 전반적인 네트워크 성능이 향상된다
#### MTU와의 관계성
MSS는 MTU와 직접적인 관계가 있다. 일반적으로 MSS는 MTU에서 TCP와 IP헤더의 크기를 뻰 값으로 측정된다. 
ex) 이더넷의 기본 MTU는 1500바이트이다, 이 경우, TCP와 IP헤더를 합친 40바이트 를 뺀 1460바이트가 MSS로 설정된다
```mss
MSS = MTU - (TCP 헤더 + IP 헤더)
MSS = 1500 - 40 = 1460 바이트
```
참고사항: 
- Path MTU Discovery (PMTUD): 네트워크 경로에서 허용되는 MTU를 동적으로 감지하여 MSS를 최적화하는 기술
- Jumbo Frames: MTU가 1500바이트보다 큰 네트워크 환경에서 사용되는 패킷의 크기 (ex: 9000바이트), 이 경우에는 MSS도 이에 맞춰 적용 될 수 있다.
### Window Scaling
최대 65,535바이트의 제한을 넘는 더 큰 수신기 창 크기를 지원하는 Transmission Control protocol(TCP)의 메커니즘이다. 이 TCP 기능은 프레임이 지연되거나 빠르게 전송될 수 있는 높은 지연 시간 또는 고대역폭 네트워크(게임 서버 한정)를 처리할 때 필수적이다
연결이 설정되면 스케일 인수를 변경할 수 없다

### 연결 (Connection)
`Connection`는 서버측 게임 개발과 클라이언트쪽 서버 개발의 링크 설정을 말한다. 
이 연결은 게임의 요구 사항에 따라 지속적과 비 지속적으로 나뉜다

<h4>주요 개념:</h4>
- 클라이언트: 게임을 실행하는 플레이어의 기기
- 서버: 게임의 상태를 관리하고, 클라이언트 간의 데이터 동기화를 담당하는 중앙 시스템
- 세션: 클라이언트와 서버간의 지속적인 연결상태

#### 지속적 연결
지속적 연결은 사용자가 로그인하는 동안 서버와 클라이언트 간의 연결이 유지되는 형태다.
주로 실시간 멀티플레이어 게임에서 사용된다
<h5>주요특징:</h5>
- 실시간 통신
- 상태유지
- 낮은 지연 시간
#### 비지속적 연결
비지속적 연결은 원할 때마다 서버와 클라이언트간에 연결을 설정하고, 작업이 완료되면 연결이 종료되는 형태다
주로 싱글플레이어 게임이나 실시간성이 낮은 클라이언트에 사용된다
<h5>주요특징:</h5>

- 연결 사용 설정 및 종료
- 자원 절약
- 높은 오버헤드

#### 연결 프로토콜 선택(나중에 TCP vs UDT로 옮길 예정)
1. TCP
	- 신뢰성
	- 연결 지향적
	- 오버헤드
	- 용도: 채팅, 로그인, 게임 상태 업데이트 등
2. UDT
	- 비신뢰성
	- 비연결 지향적
	- 낮은 오버헤드
	- 용도: 실시간 게임 업데이트, 위치 정보, 프레임 업데이트 등

#### 데이터 동기화
##### 상태 동기화
- 주 서버 모델: 중앙서버가 모든 게임 상태가 관리하고, 클라이언트에게 상태를 전달한다
- Peer-to-Peer 모델: 클라이언트간에 직접 데이터를 교환하여 상태를 동기화한다. (보안 취약 및 일관성 유지 힘듬)
##### 이벤트 기반 동기화
* 이벤트 전송: 클라이언트의 동작을 이벤트로 전송하고, 서버가 이를 처리하여 다른 클라이언트로 전송합니다.
* 명령패턴<sup>Command Pattern</sup> : 클라이언트의 명령을 서버가 실행하고 결과를 전송합니다.

##### 에측 및 보정
- 클라이언트 보정: 클라이언트가 서버의 응답을 기다리지 않고 동작을 예측하여 화면에 반영한다
- 서버보정: 서버의 실제 상태를 기반으로 클라이언트의 상태를 보정하여 일관성을 유지한다
##### 멀티플레이 환경에서의 연결 관리
다수의 클라이언트와 연결을 해야하는데, 이를 효율적으로 처리하기 위한 방법은 다음과 같다.
- **스레드 풀**: 각 클라이언트와 연결을 별도의 스레드로 처리하는 대신, 스레드 풀을 사용하여 자원을 효율적으로 관리한다
- **비동기 I/O**: 비동기 입출력 방식을 사용하여 단일 스레드에서 여러 클라이언트의 요청을 처리한다.
##### 로드 밸런싱
- **로드밸런서 사용**: 여러 서버 인스턴스에 트래픽을 분산시켜 서버 부하를 균등하게 유지한다
- **세션 스티키니스<sup>Session Stickiness</sup>**: 특정 클라이언트가 항상 동일한 서버에 연결되도록 설정하여 세션관리를 용이하게 한다
##### 서버 클러스터링
- **수평 확장**: 서버 인스턴스를 추가하여 클라이언트 수 증가에 대응한다
- **분산 데이터베이스**: 서버간에 데이터를 분산하여 저장하고, 빠른 접근을 허용한다
### 리소스 사용 개요
서버 개발에서는 리소스를 효율적으로 관리하는 것이 게임 성능과 직접적으로 연관이 있다. 리소스 관리가 잘 이뤄지지 않으면 서버 과부화, 지연 시간 증가, 서비스 중단과 같은 문제가 생길 수 있다

#### 주요 리소스 종류
##### CPU
- 역할: 게임 로직 처리, 데이터 처리, 네트워크 통신 등
- 문제점: 높은 CPU 사용률은 서버 응답을 저하시킬 수 있다
##### 메모리
- 역할: 게임 상태, 세션, 캐시데이터 저장
- 문제점: 메모리 누수, 과도한 메모리 사용은 서버 성능 저하와 크래시를 유발 가능
##### 네트워크
- 역할: 클라이언트와 서버간에 데이터 전송 담당
- 문제점: 네트워크 지연이나 대역폭 부족은 게임 플레이어의 실시간성 저해
#### 저장소
- 역할: 게임 데이터, 로그 저장
- 문제점: 느린 디스크 I/O는 데이터 접근속도↓, 저장소 용량 부족은 데이터 손실 유발 가능
#### 리소스 최적화
##### CPU 최적화
- 멀티스레딩 및 병렬 처리
- 효율적인 알고리즘 사용
- 프로파일링 도구 활용
##### 메모리 최적화
- 메모리 관리
- 메모리 누수 방지
- 데이터 구조 최적화
##### 네트워크 최적화
- 데이터 압축
- 패킷 크기 조정
- CDN(Content Delivery Network)
- 프로토콜 선택: 실시간 게임에서는 UDP를, 신뢰성이 중요한 데이터에는 TCP를 사용하여 최적의 성능을 도모한다
##### 저장소 최적화
- 데이터베이스 인덱싱
- 데이터 분할(Sharding)
- 캐싱
- SSD 사용
#### 서버 확장 및 스케일링
##### 수평적 확장 (Horizontal Scaling)
- 방법: 서버 인스터스를 추가하여 부하 분산
- 장점: 유연한 확장, 내결함성 향상
- 단점: 데이터 일관성 관리의 복잡성 증가
##### 수직정 확장 (Vertical Scaling)
- 방법: 기존서버의 CPU, 메모리, 저장소 등을 업그레이드 한다
- 장점: 단순한 확장 방식, 기존 아키텍처 변경 X
- 단점: 확장의 한계, 비용 증가
##### 클라우드 서비스 활용
- AWS, Azure, Google Cloud: 클라우드 서비스를 활용하여 필요에 따라 리소스를 동적으로 확장 가능
- 장점: 유연성, 확장성, 다양한 관리 도구 제공
- 단점: 비용 관리의 복잡성, 클라우드 존속성
#### 모니터링 및 분석
##### 모니터링 도구
- Prometheus: 실시간 모니터링 및 경고 시스템 구축
- Grafana: 시각화 대시보드 생성
- New Relic, Datadog: 종합적인 애플리케이션 모니터링
- ELK Stack (Elasticsearch, Logstach, Kibana): 로그 수집 및 분석
##### 성능 지표
- CPU 사용률: 서버의 처리 능력 평가
- 메모리 사용량: 메모리 리소스 관리
- 네트워크 대역폭: 데이터 전송 효율성 측정
- 디스크 I/O: 저장소 성능 평가
- 응답시간 및 지연시간: 사용자 경험 관련된 중요한 지표
- 에러률: 시스템의 안정성 평가
### 타임 스탬프란 무엇인가?
타임스탬프<sup>TimeStamp</sup>
## UDP
