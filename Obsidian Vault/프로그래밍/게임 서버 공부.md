즐 겁 다 !

# 사용 언어

여러개의 언어로 사용되지만 주로  PHP, Ruby, Python, .NET, Java or JS 등을 사용한다
각자의 장단점이 있다

| 언어                       | 장점                                                              | 단점                                                |
| ------------------------ | --------------------------------------------------------------- | ------------------------------------------------- |
| **C++**                  | - 높은 성능과 효율성  <br>- 하드웨어 제어에 강함  <br>- 많은 게임 엔진과 호환             | - 복잡한 메모리 관리  <br>- 학습 곡선이 가파름                    |
| **Java**                 | - 플랫폼 독립성 (JVM 기반)  <br>- 풍부한 라이브러리와 프레임워크  <br>- 안정적인 멀티스레딩 지원 | - 상대적으로 낮은 실행 속도  <br>- 메모리 사용량이 많을 수 있음          |
| **C#**                   | - Unity와의 높은 호환성  <br>- 생산성이 높고 쉬운 문법  <br>- 강력한 .NET 생태계       | - 특정 플랫폼에 종속적일 수 있음  <br>- 네이티브 성능이 C++보다 낮을 수 있음 |
| **Go**                   | - 간결한 문법과 빠른 컴파일 속도  <br>- 효율적인 동시성 처리  <br>- 쉬운 배포             | - 상대적으로 제한된 라이브러리 생태계  <br>- 게임 서버 특화 기능 부족       |
| **JavaScript (Node.js)** | - 비동기 I/O 처리에 강함  <br>- 빠른 개발 속도  <br>- 풍부한 패키지 생태계             | - 단일 스레드 모델로 인한 CPU 집약적 작업에 부적합  <br>- 콜백 지옥 가능성  |
| **Python**               | - 쉬운 학습과 빠른 프로토타이핑  <br>- 풍부한 라이브러리  <br>- 높은 생산성               | - 낮은 실행 속도  <br>- 대규모 서버에 적합하지 않을 수 있음            |
| **Rust**                 | - 메모리 안전성과 높은 성능  <br>- 현대적인 문법과 기능  <br>- 병행성에 강함              | - 비교적 새로운 언어로 학습 자료가 적을 수 있음  <br>- 컴파일 시간이 김     |
그렇다나 뭐라나..

# TCP와 UDP
## TCP

### TCP가 무엇인지
주로 게임의 채팅, 로그인 서버등을 맡는다. TCP는 두 호스트가 연결을 확인하고 데이터를 교환 할 수 있게 만든다.
이 통신 중, TCP는 오류 검사 매커니즘과 손실된 데이터를 재전송하는 시스템을 제공하여 데이터가 손상되거나 순서가 맞지 않게 수신되지 않도록 된다
네트워크 통신 중, 네트워크 리소스를 효율적으로 처리하기 위해 TCP는 흐름 제어, 혼잡 제어를 구현하고, 호스트가 연결의 처리량을 동적으로 조정할 수 있게 한다

주요 특징들을 정리하자면 :
- 연결 지향적: 통신이 시작하기 전에 연결을 설정하고 통신이 끝나면 연결을 종료한다
- 신뢰성: 위에 상술한 이유로, 손상되거나 순서가 맞지 않다면 재전송으로 정확하게 전달한다
- 흐름 제어: 송신자와 수신자간의 전송 속도를 조정하여 네트워크가 혼잡한 것을 방지 할 수 있다.
- 혼잡 제어: 네트워크 상태에 따라 전송속도를 적절히 조절하여 혼잡을 방지 할 수 있다

### 장단점
장점:
1. 신뢰성: 패킷 손실이나 순서 변경 없이 데이터가 정확히 전송된다. 채팅메시지, 게임 상태 업데이트에 유리함
2. 데이터 무결성: 데이터가 손상되지 않고 전달 되므로 게임로직의 일관성을 유지 할 수 있다
3. 연결 관리: 연결을 통해 클라이언트와 서버간에 지속적으로 연결 가능

단점:
1. 지연 시간(Latency): 데이터 전송 전에 연결 설정 및 확인 과정이 필요하여 지연 시간이 늘어 날 수 있다
2. 오버헤드[^1] : 신뢰성을 보장하기 위해 추가적인 확인 정보와 제어 메시지가 필요하여 네트워크 오버헤드가 발생한다
3. 혼잡관리: 혼잡 제어 메커니즘으로 인해 데이터 전송 속도가 변동될 수 있다

[^1]: 어떤 처리를 하기 위해 들어가는 간접적인 시간 · 메모리 등을 말한다

### TCP를 게임서버에 적용시키는 방법
#### 서버-클라이언트 아키텍쳐 설계
- 서버: 중앙에서 서버 상태를 관리하여 클라이언트 요청을 처리 할 수 있다
- 클라이언트: 사용자의 입력을 서버에 전송하고, 서버로부터 게임 상태를 수신하여 화면에 표시한다
#### 소켓 프로그래밍
TCP 통신을 구현하기 위해 소켓 프로그래밍을 사용한다
단계 예시: 
  서버
 1. 소켓 생성
 2. 주소 바인딩[^2]
 3. 연결 대기
 4. 연결 수락
 5. 데이터 송수신
 6. 연결 종료

  클라이언트:
  1. 소켓 생성
  2. 서버 연결
  3. 데이터 송수신
  4. 연결 종료

[^2]: 논리적 주소를 물리적 주소로 바꾸는 것 
#### 멀티스레딩 및 비동기 처리
게임서버는 여러 클라이언트와 동시에 통신해야 하므로, 멀티스레딩이나 비동기 I/O작업[^3]을 처리하여 자원사용을 최적화 한다
- 멀티스레딩: 각 클라이언트의 연결을 별도의 스레드에서 처리하여 동시성을 확보한다
- 비동기 I/O: 단일 스레드에서 비동기적으로 여러 클라이언트의 I/O 작업을 처리하여 자원사용을 최적화 한다.

[^3]: 사람에게 입력을 받아 출력하는 것

#### 데이터 직렬화 및 프로토콜 설계

게임서버와 클라이언트 간의 데이터 교환을 효율적으로 하기 위해, 데이터 직렬화 방법과 통신 프로토콜을 설계 해야한다
- 직렬화: 데이터를 바이트 스트림[^4]으로 변환하여 전송한다
- 프로토콜: 데이터 구조와 통신 규칙을 정의한다 ex) 메시지의 타입, 길이, 페이로드[^5]등

[^4]: 바이트 단위로 데이터를 전송하는 것
[^5]: 전송되는 순수한 데이터, 데이터와 함께 전송되는 헤더, 메타데이터 등은 제외한다

#### 에러 처리 및 재연결 로직
TCP 통신중 일어날 수 있는 에러 상황을 처리하고, 클라이언트가 예기치않게 연결이 끊어진 경우 재연결 로직을 구현해야 한다

### 최적화 및 성능 향상 팁
#### 패킷[^6] 크기 최소화
[^6]: 네트워크가 전달하는 데이터의 형식화된 블록

전송하는 데이터의 크기를 최소화하여 네트워크 대역폭을 효율적으로 사용한다. 불필요한 데이터를 제거하고, 압축 기법을 이용할 수 있다
#### 패킷 병합

여러 개의 작은 패킷을 하나로 병합하여 전송함으로써 네트워크 오버헤드를 줄일 수 있다

#### Keep-Alive 설정

TCP연결이 일정시간 동안 유지되지 않을 경우 자동으로 연결을 종료하는 Keep-Alive설정을 통해 리소스를 효율적으로 관리할 수 있다

#### 쓰레드 풀 사용

멀티스레딩 시, 쓰레드 풀[^7]을 사용하여 스레드 생성 및 소멸에 따른 오버헤드를 줄이고 성능을 향상시킬 수 있다

[^7]: 동시에 실행되는 작업을 관리하는 데 사용되는 메커니즘
#### 비동기 I/O 활용

비동기 I/O를 활용하여 블로킹 없이 다수의 클라이언트를 효율적으로 처리 가능하다
### 보안 고려사항
#### 데이터 암호화
중간에 데이터가 탈취되지 않도록 SSL/TLS[^8]를 사용하여 데이터 전송을 암호화한다

[^8]: SSL은 Secure Sockets Layer 즉, 보안 소켓 계층, TLS는 Transport Layer Security 즉, 전송 계층 보안을 의미
#### 인증 및 권한 부여
클라이언트의 인증 절차를 통해 허가되지 않은 접근 을 차단한다
#### 입력 검증
클라이언트로부터 수신된 데이터를 철저히 검증하여 악의적인 공격을 방지합니다.
### TCP 체크섬
#### TCP 체크섬이란?
TCP 헤더의 16비트 필드로 오류 검사를 수행하는데 사용된다. TCP 스택은 전송된 데이터에 대한 체크섬 값을 계산하여 데이터와 함께 계산된 값과 비교한다. 두 계산 값이 일치하면 전송 오류가 없는 것으로 판단하고, 만약 일치하지 않다면 TCP는 수신된 데이터의 변경을 감지하고 수신기는 손실되거나 손상된 데이터 패킷의 재전송을 요청한다.

기능을 요약하자면:
1. 오류 검출: 전송 중 발생 할 수 있는 비트 오류, 데이터 수신등을 감지한다
2. 데이터 무결성 보장: 데이터가 송신자에서 수신자까지 전달되는 동안 변경되지 않았음을 보장한다
3. 신뢰성 향상: 신뢰할 수 없는 네트워크 환경에서도 데이터의 정확한 전달을 보장한다
##### 체크섬의 중요성

서버 사이드 게임 개발에서 체크섬은 여러 가지 측면에서 중요합니다:

- **데이터 무결성 보장**: 게임 클라이언트와 서버 간의 데이터 전송 시, 데이터가 손상되지 않았는지 확인할 수 있습니다.
- **보안 강화**: 체크섬을 통해 데이터 변조를 탐지할 수 있어, 해커의 공격을 어느 정도 방어할 수 있습니다.
- **디버깅 및 문제 해결**: 데이터 전송 오류를 신속하게 감지하고 문제를 해결하는 데 도움이 됩니다.

##### 체크섬의 종류

체크섬에는 여러 종류가 있으며, 각각의 특성과 용도가 다릅니다. 주요 체크섬 알고리즘은 다음과 같습니다:

###### 단순 체크섬 (Simple Checksum)

가장 기본적인 형태로, 데이터의 모든 바이트 값을 단순히 합산하여 특정 값으로 만드는 방법이다. 구현이 간단하지만 오류 검출 능력이 낮다.

###### 순환 중복 검사 (CRC, Cyclic Redundancy Check)

더 복잡한 알고리즘으로, 데이터의 다항식을 사용하여 계산된다. CRC는 단순 체크섬보다 높은 오류 검출 능력을 가지고 있으며, 네트워크 통신에서 널리 사용된다.

###### 해시 기반 체크섬 (Hash-based Checksum)

MD5, SHA-1, SHA-256 등과 같은 해시 알고리즘을 사용하여 데이터의 고유한 해시 값을 생성한다. 높은 보안성을 제공하지만, 계산 비용이 상대적으로 높다.

###### 해시 함수 vs 체크섬

해시 함수는 체크섬보다 더 복잡한 연산을 수행하여 데이터의 무결성을 확인하고, 보안성을 강화합니다. 그러나 체크섬은 속도와 간단함이 장점이다.

##### 게임 개발에서의 체크섬 활용
###### 데이터 전송 무결성 확인
클라이언트와 서버간에 패킷 전송시, 체크섬을 사용하여 데이터가 손상되지않고 정확하게 전달 되었는지 확인이 가능하다
###### 게임 데이터 검증
게임 내에서 중요한 데이터(ex: Player State, Game State etc..)의 무결성을 위해 체크섬 활용 가능
###### 보안 강화
체크섬을 통해 데이터 변조를 탐지하고, 해킹 시도를 어느 정도 방어할 수 있다.
### 세그먼트 구조
TCP는 **세그먼트화**라는 방법을 사용하여 데이터 전송을 관리한다. 이 접근 방식에서 TCP는 데이터 스트림을 "세그먼트"라고 하는 더 작은 부분으로 나눈다. 그런 다음 이러한 세그먼트들을 인터넷을 통해 독립적으로 전송한다. 기본 TCP 세그먼트는 헤더와 데이터 섹션으로 나뉘는데, 헤더에는 소스 포트, 대상 포트, 시퀀스 번호, 확인 번호, 데이터 오프셋, 예약 섹션, 제어 비트, 창, 체크섬, 긴급 포인터 및 옵션과 같은 다양한 필드로 포함된다. 나머지 세그먼트는 TCP가 전송하는 데이터로 채워진다.

#### 주요 개념
- 패킷(Packet): 네트워크를 통해 전송되는 데이터의 기본 단위
- 헤더(Header): 패킷의 메타데이터를 포함하는 부분
- 페이로드(Payload): 실제 전송되는 데이터
#### 중요한 이유?
- 효율적인 데이터 전송: 불필요한 데이터를 줄이고 필요한 정보만 전송하여 대역폭을 절약한다.
- 데이터 무결성 보장: 전송 중 데이터 손상이나 오류를 감지하고 복구할 수 있다.
- 보안 강화: 데이터 변조나 도청을 방지하기 위한 보안 메커니즘을 포함할 수 있다.
- 확장성: 새로운 기능이나 데이터 유형을 쉽게 추가할 수 있는 유연성을 제공한다.
#### 세그먼트 구조 설계 원칙
##### 명확한 정의
세그먼트의 각 필드와 그 역할을 명확히 정의하여 클라이언트와 서버 모두 동일하게 해석 할 수 있게 한다
##### 확장성
새로운 기능이나 데이터유형을 쉽게 추가할 수 있도록 유연한 구조를 설계한다. ex) 버전 필드를 포함하여 구조 변경시 호환성 유지

##### 효율성
데이터 전송의 효율성을 높이기 위해 필요한 정보만 기입 해야한다. 데이터를 압축, 최적화 하여 저장한다

##### 보안
데이터의 기밀성과 무결성을 위한 보안 메커니즘을 포함해야 한다
ex) 암호화, 인증필드등

#### 직렬화와 역직렬화
세그먼트 구조는 바이너리 형태로 전송되지만, 다양한 프로그래밍 언어에서 호환되도록 데이터를 직렬화<sup>serialize</sup>하고 역직렬화<sup>deserialize</sup>해야 한다.
##### 직렬화
객체나 데이터를 일련의 바이트로 만드는 과정을 말한다. 
일반적인 데이터 포맷은 다음과 같다:

| 데이터 포맷          | 설명                        |
| --------------- | ------------------------- |
| JSON            | 가독성이 높고 인간이 읽기 쉬운 방식      |
| Protocal Buffer | 구글에서 개발한 효율적인 바이너리 직렬화 포맷 |
| MessagePack     | 이진 데이터 직렬화를 지원하는 포맷       |
| FlatBuffers     | 빠른 직렬화와 역 직렬화를 지원하는 포맷    |
##### 역직렬화
직렬화된 데이터를 원래의 객체나 데이터 구조로 복원하는 과정이다. 클라이언트와 서버는 동일한 직렬화 포맷을 이용해야 한다

#### 다양한 데이터 처리
게임 서버는 다양한 유형의 데이터를 주고받는다. 이를 효과적으로 처리하기 위해 세그먼트 구조를 유연하게 설계해야한다
##### 플레이어 동작
플레이어의 움직임, 공격, 아이템 사용 등의 동작을 전송할 때는 해당 동작에 맞는 정보(ex: 위치, 방향, 동작 유형)을 페이로드에 포함시킨다.
##### 게임 상태 업데이트
게임의 현재 상태, ex) NPC 위치, 아이템 상태, 퀘스트 정보들을 주기적으로 업데이트 할 때 사용된다.
##### 채팅 메시지
플레이어 간에 채팅 메시지를 전송할 때는 메시지 내용과 발신자 정보를 포함시킨다
##### 시스템 메시지
서버의 알림, 메시지, 공지사항등을 전송할 때에 사용된다
#### 버전 관리 및 확장성
다음은 버전 관리 및 확장성의 팁들이다. 이미 알고 있다면 다음 챕터로
1. 버전 필드 추가
2. 유연한 필드 처리
3. 하위 호환성
### MSS란 무엇인가?
최대 세그먼트 크기<sup>Meximum Segment Size, MSS</sup>는 TCP 프로토콜로 한 번에 전송할 수 있는 최대 패킷 크기(MTU: Maximum Transmission Unit)를 고려하여 결정한다. MSS는 주로 TCP 연결 설정 시 협상되며, 데이터 전송의 효율성과 신뢰성을 유지하는데 중요한 역할을 한다
## UDP
